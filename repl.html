<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Subscript REPL</title>
<style>
* { box-sizing: border-box; margin: 0; padding: 0; }
html { font-size: 16px; }
:root {
  --bg: #0d1117; --bg2: #161b22; --fg: #e6edf3; --accent: #58a6ff;
  --err: #f85149; --ok: #3fb950; --muted: #8b949e; --border: #30363d;
  --ln: #484f58;
}
body { font: 1rem/1.5 ui-monospace, SFMono-Regular, Menlo, Monaco, monospace; background: var(--bg); color: var(--fg); min-height: 100vh; display: flex; }
.wrap { display: flex; flex-direction: row; flex: 1; min-height: 0; }

/* Dark scrollbars */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--muted); }

/* Main */
main { flex: 1; padding: 1rem; display: flex; flex-direction: column; gap: 0.5rem; min-width: 0; }

/* Header */
header { display: flex; align-items: center; gap: 0.625rem; }
h1 { font-size: 1rem; font-weight: 600; }
h1 span { color: var(--accent); }
.toggle-sidebar { margin-left: auto; background: none; border: none; color: var(--muted); padding: 0.25rem 0.5rem; cursor: pointer; font: inherit; font-size: 0.875rem; display: flex; align-items: center; gap: 0.25rem; }
.toggle-sidebar:hover { color: var(--fg); }
.toggle-sidebar svg { width: 0.875rem; height: 0.875rem; }

/* Code area - editor only */
.code-area { display: flex; gap: 1rem; align-items: flex-start; }

/* Editor with line numbers */
.editor { display: flex; position: relative; overflow: auto; max-height: 50vh; min-width: 200px; flex: 1; max-width: 80ch; }
.line-nums {
  padding: 0.5rem; color: var(--ln); font-size: 0.875rem; line-height: 1.6;
  text-align: right; user-select: none; white-space: pre; min-width: 1.75rem;
  position: sticky; left: 0; background: var(--bg);
}
#input {
  flex: 1; background: transparent; border: none; color: var(--fg);
  padding: 0.5rem 0.5rem 0.5rem 0.25rem; font: inherit; outline: none; tab-size: 2; line-height: 1.6;
  resize: none; overflow: hidden; min-height: 1.6em;
  white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;
}
#input::placeholder { color: var(--muted); }
.eval-panel .eval-time { color: var(--muted); font-size: 0.75rem; }

/* Info bar - errors only */
.info-bar { display: flex; align-items: center; padding: 0.25rem 0 0.25rem 2.25rem; font-size: 0.875rem; min-height: 1.25rem; max-width: 80ch; }
.info-bar .error { color: var(--err); flex: 1; }

/* Output section - tabs */
.output-section { display: flex; flex-direction: column; max-width: 80ch; }
.output-tabs { display: flex; gap: 0; border-bottom: 1px solid var(--border); }
.output-tab { background: none; border: none; color: var(--muted); padding: 0.375rem 0.75rem; font: 0.875rem inherit; cursor: pointer; border-bottom: 2px solid transparent; margin-bottom: -1px; }
.output-tab:hover { color: var(--fg); }
.output-tab.active { color: var(--fg); border-bottom-color: var(--accent); }
.output-panel { display: none; padding: 0.5rem 0; }
.output-panel.active { display: block; }
#ast { font-size: 0.875rem; color: var(--muted); white-space: pre; line-height: 1.5; }

/* Eval section */
.eval-content { padding: 0.5rem 0; display: flex; flex-direction: column; gap: 0.5rem; font-size: 0.875rem; }
.eval-field { display: flex; flex-direction: column; gap: 0.25rem; }
.eval-content .label { color: var(--muted); font-size: 0.75rem; text-transform: uppercase; letter-spacing: .03em; }
.eval-content textarea {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  color: var(--fg); font: inherit; outline: none; padding: 0.25rem 0.5rem;
  resize: none; overflow: hidden; width: 100%;
  white-space: pre; font-size: 0.875rem; min-height: 2em;
}
.eval-content textarea:focus { border-color: var(--accent); }
.eval-content textarea::placeholder { color: var(--border); }
#result {
  background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 0.25rem 0.5rem; min-height: 1.5rem; color: var(--ok); font-weight: 500;
  word-break: break-all; white-space: pre-wrap; font-size: 0.875rem;
}
#result.err { color: var(--err); }
.run-row { display: flex; align-items: center; gap: 0.625rem; }
.eval-content .run-btn {
  background: var(--accent); color: #000; border: none; border-radius: 4px;
  padding: 0.25rem 0.625rem; font: 0.875rem inherit; cursor: pointer; display: flex; align-items: center; gap: 0.25rem;
}
.eval-content .run-btn:hover { filter: brightness(1.1); }
.eval-content .run-btn svg { width: 0.75rem; height: 0.75rem; }

/* Sidebar */
.sidebar {
  width: 16.25rem; background: var(--bg2); display: flex; flex-direction: column; flex-shrink: 0;
  transition: width .2s ease, opacity .15s;
}
.sidebar.collapsed { width: 0; opacity: 0; overflow: hidden; }

/* Sidebar header */
.sidebar-head { padding: 0.75rem 0.875rem; border-bottom: 1px solid var(--border); }
.preset-select {
  width: 100%; background: var(--bg); border: 1px solid var(--border); border-radius: 4px;
  padding: 0.375rem 1.75rem 0.375rem 0.5rem; font: 0.875rem inherit; color: var(--fg); cursor: pointer;
  appearance: none; -webkit-appearance: none;
  background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%238b949e' stroke-width='2'%3E%3Cpath d='M6 9l6 6 6-6'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.5rem center;
}
.preset-select:focus { outline: none; border-color: var(--accent); }

/* Features list */
.features { flex: 1; overflow: auto; padding: 0.625rem 0.875rem; }
.cat-head { font-size: 0.6875rem; padding: 0.5rem 0 0.25rem; color: var(--muted); text-transform: uppercase; letter-spacing: .04em; opacity: .7; }
.cat-head:first-child { padding-top: 0; }
.feat { display: flex; align-items: center; gap: 0.375rem; padding: 0.1875rem 0; cursor: pointer; font-size: 0.875rem; white-space: nowrap; }
.feat:hover { color: var(--accent); }
.feat input { accent-color: var(--accent); }
.feat-desc { color: var(--muted); font-size: 0.6875rem; margin-left: auto; }

/* Sidebar actions */
.sidebar-actions { padding: 0.75rem 0.875rem; border-top: 1px solid var(--border); }
.btn { width: 100%; padding: 0.625rem 0.75rem; border: none; border-radius: 0.375rem; cursor: pointer; font: 0.875rem inherit; display: flex; align-items: center; justify-content: center; gap: 0.375rem; }
.btn.primary { background: var(--accent); color: #000; }
.btn.primary:hover { filter: brightness(1.1); }
.btn svg { width: 0.875rem; height: 0.875rem; }

/* Modal */
.modal-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,.6); z-index: 100;
  display: flex; align-items: center; justify-content: center;
  opacity: 0; visibility: hidden; transition: opacity .15s, visibility .15s;
}
.modal-overlay.open { opacity: 1; visibility: visible; }
.modal {
  background: var(--bg2); border: 1px solid var(--border); border-radius: 0.625rem;
  width: 43.75rem; height: 31.25rem; display: flex; flex-direction: column;
  transform: scale(.95); transition: transform .15s;
}
.modal-overlay.open .modal { transform: scale(1); }
.modal-body { flex: 1; min-height: 0; padding: 1rem; display: flex; flex-direction: column; gap: 0.75rem; }
.modal-code-wrap { position: relative; flex: 1; min-height: 0; display: flex; flex-direction: column; }
.modal-code {
  background: var(--bg); border: 1px solid var(--border); border-radius: 0.375rem;
  padding: 0.75rem; font-size: 0.875rem; line-height: 1.5; overflow: auto;
  flex: 1; min-height: 0; white-space: pre; color: var(--muted);
}
.modal-code-wrap .copy-btn {
  position: absolute; top: 0.5rem; right: 0.5rem; background: var(--bg2); border: 1px solid var(--border);
  border-radius: 4px; padding: 0.25rem 0.5rem; font: 0.75rem inherit; color: var(--muted); cursor: pointer;
  display: flex; align-items: center; gap: 0.25rem; z-index: 1;
}
.modal-code-wrap .copy-btn:hover { color: var(--fg); border-color: var(--accent); }
.modal-code-wrap .copy-btn svg { width: 0.75rem; height: 0.75rem; }
.modal-actions { display: flex; gap: 0.625rem; align-items: center; flex-shrink: 0; padding-top: 0.75rem; border-top: 1px solid var(--border); }
.modal-actions .btn { width: auto; padding: 0.5rem 0.75rem; }
.modal-actions .btn.secondary { background: var(--bg); color: var(--fg); }
.modal-actions .btn.secondary:hover { background: #21262d; }
.modal-toggle { display: flex; align-items: center; gap: 0.375rem; font-size: 0.75rem; color: var(--muted); }
.modal-toggle input { accent-color: var(--accent); }
.size-info { font-size: 0.75rem; color: var(--muted); }
.modal-right { margin-left: auto; display: flex; gap: 0.625rem; align-items: center; }

/* Header links */
.header-link { color: var(--muted); text-decoration: none; opacity: 0.5; font-size: 1.125rem; line-height: 1; transition: opacity .15s, color .15s; }
.header-link:hover { opacity: 1; color: var(--accent); }
</style>
</head>
<body>
<a href="https://github.com/krishnized/license" class="header-link" style="position: absolute; bottom: 1rem; right: 1rem;" target="_blank" rel="noopener" title="krishnized license">ॐ</a>
<div class="wrap">
  <main>
    <header>
      <h1><span>subscript</span> repl</h1>
      <a href="https://github.com/dy/subscript" class="header-link" target="_blank" rel="noopener" title="github">⎇</a>
      <button class="toggle-sidebar" id="toggleSidebar">
        <span>Features</span>
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 6l6 6-6 6"/></svg>
      </button>
    </header>

    <div class="code-area">
      <div class="editor">
        <div class="line-nums" id="lineNums">1
2
3
4</div>
        <textarea id="input" placeholder="Type expression..." spellcheck="false" rows="4"></textarea>
      </div>
    </div>

    <div class="info-bar">
      <span class="error" id="error"></span>
    </div>

    <div class="output-section">
      <div class="output-tabs">
        <button class="output-tab active" data-tab="eval">Eval</button>
        <button class="output-tab" data-tab="tree">Tree</button>
      </div>

      <!-- Eval panel -->
      <div class="output-panel active" id="evalPanel">
        <div class="eval-content">
          <div class="eval-field">
            <span class="label">Context</span>
            <textarea id="context" placeholder="{}">{}</textarea>
            </div>
            <div class="eval-field">
              <span class="label">Result</span>
              <div id="result" data-testid="result"></div>
            </div>
            <div class="run-row">
              <button class="run-btn" id="runBtn" title="Run (Cmd+Enter)">
                <svg viewBox="0 0 24 24" fill="currentColor"><path d="M8 5v14l11-7z"/></svg>
                Run
              </button>
              <span class="eval-time" id="evalTime"></span>
            </div>
          </div>
        </div>
      </div>

      <!-- Tree panel -->
      <div class="output-panel" id="treePanel">
        <pre id="ast"></pre>
      </div>
    </div>
  </main>

  <aside class="sidebar" id="sidebar">
    <div class="sidebar-head">
      <select class="preset-select" id="presetSelect" data-testid="preset">
        <option value="minimal">Minimal</option>
        <option value="expr">Expressions</option>
        <option value="justin" selected>Expr + JSON</option>
        <option value="full">Full</option>
        <option value="custom" disabled hidden>Custom</option>
      </select>
    </div>
    <div class="features" id="features"></div>
    <div class="sidebar-actions">
      <button class="btn primary" id="getBundleBtn">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M4 7v10c0 .55.45 1 1 1h14c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1h-5.59c-.27 0-.52-.11-.71-.29l-1.41-1.41c-.19-.19-.44-.3-.71-.3H5c-.55 0-1 .45-1 1z"/></svg>
        Export
      </button>
    </div>
  </aside>
</div>

<!-- Bundle modal -->
<div class="modal-overlay" id="bundleModal">
  <div class="modal">
    <div class="modal-body">
      <div class="modal-code-wrap">
        <button class="copy-btn" id="codeCopyBtn">
          <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M19.4 20H9.6a.6.6 0 01-.6-.6V9.6a.6.6 0 01.6-.6h9.8a.6.6 0 01.6.6v9.8a.6.6 0 01-.6.6z"/><path d="M15 9V4.6a.6.6 0 00-.6-.6H4.6a.6.6 0 00-.6.6v9.8a.6.6 0 00.6.6H9"/></svg>
          Copy
        </button>
        <pre class="modal-code" id="modalCode"></pre>
      </div>
      <div class="modal-actions">
        <span class="size-info" id="sizeInfo">0 B</span>
        <div class="modal-right">
          <label class="modal-toggle">
            <input type="checkbox" id="bundleToggle">
            <span>bundle</span>
          </label>
          <label class="modal-toggle">
            <input type="checkbox" id="minToggle">
            <span>min</span>
          </label>
          <button class="btn primary" id="modalDownload" title="Download">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M6 20h12M12 4v12m0 0l3.5-3.5M12 16l-3.5-3.5"/></svg>
            Save
          </button>
        </div>
      </div>
    </div>
  </div>
</div>

<script type="module">
const featureOrder = ['number', 'string', 'access', 'call', 'group', 'assign', 'mult', 'add',
  'increment', 'bitwise', 'logic', 'compare', 'shift', 'pow', 'bool', 'array', 'object',
  'ternary', 'arrow', 'optional', 'spread', 'comment', 'block', 'if', 'loop', 'var']

const FEATURES = [
  { cat: 'Core', items: ['number', 'string', 'access', 'call', 'group'] },
  { cat: 'Operators', items: ['assign', 'mult', 'add', 'increment', 'bitwise', 'shift', 'pow', 'compare', 'logic'] },
  { cat: 'Literals', items: ['bool', 'array', 'object'] },
  { cat: 'Advanced', items: ['ternary', 'arrow', 'optional', 'spread', 'comment'] },
  { cat: 'Control', items: ['if', 'loop', 'var'] },
]

const DESC = {
  number: '1, .5', string: '"x"', access: 'a.b', call: 'f()', group: '()',
  assign: '=', mult: '*/%', add: '+-', increment: '++', bitwise: '&|^', shift: '<<', pow: '**',
  compare: '==<>', logic: '&&!', bool: 'true', array: '[]', object: '{}',
  ternary: '?:', arrow: '=>', optional: '?.', spread: '...', comment: '//',
  'if': 'if/else', loop: 'for/while', 'var': 'let/const'
}

// Multiline example templates for different feature combinations
const TEMPLATES = {
  full: {
    code: `let x = 10; let y = 20; if (x > 5) { y = y + x } else { y = y - x }; y`,
    ctx: {}
  },

  justin: {
    code: `items
  .filter(x => x.value > threshold)
  .map(x => ({
    ...x,
    doubled: x.value * 2,
    label: x.active ? "on" : "off"
  }))
  .reduce((sum, x) => sum + x.doubled, 0)`,
    ctx: {
      items: [
        { value: 10, active: true },
        { value: 5, active: false },
        { value: 20, active: true }
      ],
      threshold: 8
    }
  }
}

// Generate example based on enabled features
function generateExample() {
  const has = f => selected.has(f)
  const all = f => f.every(has)

  // Full subscript with control flow
  if (all(['var', 'loop', 'if', 'arrow', 'spread', 'ternary', 'optional', 'object', 'array', 'compare', 'logic', 'comment'])) {
    return TEMPLATES.full
  }

  // Justin preset - functional style
  if (all(['arrow', 'call', 'access', 'spread', 'ternary', 'object', 'array', 'compare', 'mult', 'add', 'comment'])) {
    return TEMPLATES.justin
  }

  // Has control flow - build multiline program
  if (has('var') || has('loop') || has('if')) {
    const lines = []
    const ctx = {}

    if (has('var')) {
      lines.push('let x = 10')
      lines.push('let y = 20')
    }

    if (has('array') && has('var')) {
      lines.push('let nums = [1, 2, 3, 4, 5]')
      ctx.nums = [1, 2, 3, 4, 5]
    }

    if (has('if') && has('compare')) {
      lines.push('')
      lines.push('if (x > 5) {')
      lines.push('  y = y + x')
      lines.push('} else {')
      lines.push('  y = y - x')
      lines.push('}')
    } else if (has('if')) {
      lines.push('')
      lines.push('if (flag) {')
      lines.push('  x = 1')
      lines.push('} else {')
      lines.push('  x = 0')
      lines.push('}')
      ctx.flag = true
    }

    if (has('loop') && has('compare') && has('increment')) {
      lines.push('')
      lines.push('let sum = 0')
      lines.push('for (let i = 0; i < 5; i++) {')
      lines.push('  sum = sum + i')
      lines.push('}')
    }

    if (has('arrow') && has('call') && has('access') && has('array')) {
      lines.push('')
      lines.push('nums.map(n => n * 2)')
    } else if (lines.length > 0) {
      lines.push('')
      lines.push(has('var') ? 'x + y' : 'result')
    }

    if (lines.length > 0) {
      return { code: lines.join('\n'), ctx }
    }
  }

  // Expression-only (no control flow) - build compound expression
  if (has('arrow') && has('call') && has('access') && has('array')) {
    if (has('spread') && has('object') && has('ternary')) {
      return {
        code: `items.map(x => ({
  ...x,
  status: x.value > 10 ? "high" : "low"
}))`,
        ctx: { items: [{ value: 5 }, { value: 15 }, { value: 8 }] }
      }
    }
    if (has('ternary') && has('compare')) {
      return {
        code: `data
  .filter(x => x.score > threshold)
  .map(x => x.score * 2)`,
        ctx: { data: [{ score: 80 }, { score: 60 }, { score: 90 }], threshold: 70 }
      }
    }
    return {
      code: `nums.map(n => n * multiplier)`,
      ctx: { nums: [1, 2, 3, 4], multiplier: 10 }
    }
  }

  if (has('ternary') && has('compare') && has('logic')) {
    return {
      code: `x > 0 && x < 100
  ? x * 2
  : 0`,
      ctx: { x: 50 }
    }
  }

  if (has('ternary') && has('compare')) {
    return {
      code: `a > b ? a : b`,
      ctx: { a: 42, b: 17 }
    }
  }

  if (has('mult') && has('add') && has('group')) {
    return {
      code: `(a + b) * (c - d)`,
      ctx: { a: 10, b: 5, c: 8, d: 3 }
    }
  }

  if (has('mult') && has('add')) {
    return {
      code: `a * b + c * d`,
      ctx: { a: 2, b: 3, c: 4, d: 5 }
    }
  }

  if (has('add')) {
    return { code: 'a + b + c', ctx: { a: 1, b: 2, c: 3 } }
  }

  if (has('number')) {
    return { code: '42', ctx: {} }
  }

  return { code: '1', ctx: {} }
}

const PRESETS = {
  minimal: ['number', 'string', 'access', 'group', 'add', 'mult'],
  expr: ['number', 'string', 'access', 'call', 'group', 'assign', 'mult', 'add', 'increment', 'bitwise', 'logic', 'compare', 'shift'],
  justin: ['number', 'string', 'access', 'call', 'group', 'assign', 'mult', 'add', 'increment', 'bitwise', 'logic', 'compare', 'shift', 'pow', 'bool', 'array', 'object', 'ternary', 'arrow', 'optional', 'spread', 'comment'],
  full: FEATURES.flatMap(c => c.items),
}

let selected = new Set(PRESETS.justin)
let worker = null
let currentAST = null
let workerReady = false
let evalId = 0
let currentWorker = null

// Fetch all feature sources upfront
const featureSources = {}
await Promise.all(featureOrder.map(async f => {
  const res = await fetch(`./feature/${f}.js`)
  featureSources[f] = await res.text()
}))

// Fetch core sources
const [parseSrc, compileSrc, constSrc, stringifySrc] = await Promise.all([
  fetch('./src/parse.js').then(r => r.text()),
  fetch('./src/compile.js').then(r => r.text()),
  fetch('./src/const.js').then(r => r.text()),
  fetch('./src/stringify.js').then(r => r.text()),
])

// Build worker source
function buildWorkerSrc() {
  let constCode = constSrc.replace(/^export\s+const\s+/gm, 'var ')

  let parseCode = parseSrc
    .replace(/^import\s+.*$/gm, '')
    .replace(/^export\s+let\s+/gm, 'var ')
    .replace(/^export\s+default\s+/gm, 'var parseDefault = ')

  let compileCode = compileSrc
    .replace(/^import\s+.*$/gm, '')
    .replace(/^export\s+const\s+/gm, 'var ')
    .replace(/^export\s+default\s+compile\s*;?\s*$/gm, '')
    .replace(/,\s*\/\/.*\n\s*id\s*=\s*compile\.id\s*=/g, '; compile.id =')

  let stringifyCode = stringifySrc
    .replace(/^import\s+.*$/gm, '')
    .replace(/^export\s+default\s+/gm, 'var _default = ')
    .replace(/^export\s+(const|let)\s+/gm, 'var ')
    .replace(/^export\s+function\s+/gm, 'function ')

  let src = `// Bundled subscript\n${constCode}\n${parseCode}\n${compileCode}\n${stringifyCode}\n`

  // Create P object for features that use `import * as P`
  // Use getters for idx/cur since they change during parsing
  src += `
var P = {
  parse: parse,
  token: token,
  space: space,
  expr: expr,
  skip: skip,
  next: next,
  err: err,
  get idx() { return idx },
  get cur() { return cur }
};
`

  for (const f of featureOrder) {
    // Auto-include block when if/loop is selected (it's a dependency, not user-selectable)
    const shouldInclude = f === 'block'
      ? (selected.has('if') || selected.has('loop'))
      : selected.has(f)
    if (shouldInclude) {
      let code = featureSources[f]
        .replace(/^import\s+.*$/gm, '')
        .replace(/^export\s+/gm, '')
        // Convert destructuring const { x, y } = P to individual assignments
        .replace(/^const\s*\{([^}]+)\}\s*=\s*(\w+)\s*$/gm, (_, vars, obj) => {
          return vars.split(',').map(v => v.trim()).filter(Boolean)
            .map(v => `var ${v} = ${obj}.${v}`).join('\n')
        })
      // Don't wrap block.js in IIFE - its exports need to be visible to if.js/loop.js
      if (f === 'block') {
        src += `\n// feature: ${f}\n${code}\n`
      } else {
        // Wrap in IIFE to avoid naming conflicts between features
        src += `\n// feature: ${f}\n;(function(){\n${code}\n})();\n`
      }
    }
  }

  src += `
// Worker handler
self.onmessage = function(e) {
  var data = e.data
  if (data.type === 'compile') {
    try {
      var t0 = performance.now()
      var ast = parse(data.code)
      var fn = compile(ast)
      var compileTime = performance.now() - t0
      self.postMessage({ id: data.id, ok: true, ast: ast, time: compileTime })
    } catch (err) {
      self.postMessage({ id: data.id, ok: false, error: err.message })
    }
  } else if (data.type === 'run') {
    try {
      var t0 = performance.now()
      var ast = parse(data.code)
      var fn = compile(ast)
      var result = fn(data.ctx)
      var evalTime = performance.now() - t0
      var serializable = typeof result === 'function'
        ? { __type: 'function', length: result.length }
        : result
      self.postMessage({ id: data.id, ok: true, result: serializable, time: evalTime })
    } catch (err) {
      self.postMessage({ id: data.id, ok: false, error: err.message })
    }
  }
}
self.postMessage({ type: 'ready' })
`
  return src
}

function rebuildWorker() {
  return new Promise((resolve, reject) => {
    evalId++
    workerReady = false
    clearTimeout(timer)

    if (currentWorker) {
      currentWorker.onmessage = null
      currentWorker.onerror = null
      currentWorker.terminate()
      currentWorker = null
      worker = null
    }

    const src = buildWorkerSrc()
    const blob = new Blob([src], { type: 'text/javascript' })
    const newWorker = new Worker(URL.createObjectURL(blob))

    newWorker.onmessage = e => {
      if (e.data.type === 'ready') {
        currentWorker = newWorker
        worker = newWorker
        workerReady = true
        worker.onmessage = handleWorkerMsg
        resolve()
      }
    }
    newWorker.onerror = e => {
      console.error('Worker error:', e)
      errorEl.textContent = 'Worker: ' + e.message
      reject(e)
    }
  })
}

function handleWorkerMsg(e) {
  if (e.data.id !== evalId) return

  const { ok, ast, result, error, time } = e.data
  if (ok) {
    if (ast !== undefined) {
      currentAST = ast
      astEl.textContent = formatAST(ast)
      errorEl.textContent = ''
    }
    if (result !== undefined) {
      if (result && result.__type === 'function') {
        resultEl.textContent = `ƒ(${result.length})`
      } else {
        resultEl.textContent = JSON.stringify(result) ?? String(result)
      }
      resultEl.classList.remove('err')
      evalTimeEl.textContent = time !== undefined ? `${time.toFixed(1)}ms` : ''
    }
  } else {
    errorEl.textContent = error
    evalTimeEl.textContent = ''
    if (result === undefined) {
      astEl.textContent = ''
      currentAST = null
    } else {
      resultEl.textContent = error
      resultEl.classList.add('err')
    }
  }
}

// AST formatter
function formatAST(node, depth = 0) {
  if (node === undefined) return 'undefined'
  if (node === null) return 'null'
  if (!Array.isArray(node)) return JSON.stringify(node)
  if (node.length === 0) return '[]'

  const indent = '  '.repeat(depth)
  const inner = '  '.repeat(depth + 1)

  if (node[0] === undefined && node.length === 2) return `[, ${JSON.stringify(node[1])}]`

  const simple = node.every((n, i) => !Array.isArray(n) || (i > 0 && JSON.stringify(n).length < 20))
  if (simple) {
    const inline = `[${node.map((n, i) => i === 0 && n === undefined ? '' : (Array.isArray(n) ? formatAST(n, 0) : JSON.stringify(n))).join(', ')}]`
    if (inline.length < 60) return inline
  }

  const parts = node.map((n, i) => {
    if (i === 0 && n === undefined) return ''
    return Array.isArray(n) ? formatAST(n, depth + 1) : JSON.stringify(n)
  })
  return `[${parts[0]},\n${inner}${parts.slice(1).join(`,\n${inner}`)}\n${indent}]`
}

// Compact JSON formatter - multiline but minimal
function formatJSON(obj, indent = 0) {
  const sp = '  '.repeat(indent)
  const sp1 = '  '.repeat(indent + 1)
  if (obj === null) return 'null'
  if (typeof obj !== 'object') return JSON.stringify(obj)
  if (Array.isArray(obj)) {
    if (obj.length === 0) return '[]'
    if (obj.every(v => typeof v !== 'object' || v === null)) {
      const inline = '[' + obj.map(v => JSON.stringify(v)).join(', ') + ']'
      if (inline.length < 40) return inline
    }
    return '[\n' + obj.map(v => sp1 + formatJSON(v, indent + 1)).join(',\n') + '\n' + sp + ']'
  }
  const keys = Object.keys(obj)
  if (keys.length === 0) return '{}'
  if (keys.length <= 2 && keys.every(k => typeof obj[k] !== 'object' || obj[k] === null)) {
    const inline = '{ ' + keys.map(k => JSON.stringify(k) + ': ' + JSON.stringify(obj[k])).join(', ') + ' }'
    if (inline.length < 50) return inline
  }
  return '{\n' + keys.map(k => sp1 + JSON.stringify(k) + ': ' + formatJSON(obj[k], indent + 1)).join(',\n') + '\n' + sp + '}'
}

// Elements
const inputEl = document.getElementById('input')
const lineNumsEl = document.getElementById('lineNums')
const errorEl = document.getElementById('error')
const evalTimeEl = document.getElementById('evalTime')
const astEl = document.getElementById('ast')
const resultEl = document.getElementById('result')
const contextEl = document.getElementById('context')

// Auto-resize textarea + line numbers
function updateEditor() {
  const lines = inputEl.value.split('\n').length
  lineNumsEl.textContent = Array.from({ length: lines }, (_, i) => i + 1).join('\n')
  inputEl.style.height = 'auto'
  inputEl.style.height = inputEl.scrollHeight + 'px'
}
inputEl.addEventListener('input', updateEditor)
updateEditor()

// Auto-resize context textarea
function resizeContext() {
  contextEl.style.height = 'auto'
  contextEl.style.height = contextEl.scrollHeight + 'px'
}
contextEl.addEventListener('input', resizeContext)

// Auto-format context JSON on blur
contextEl.addEventListener('blur', () => {
  try {
    const parsed = JSON.parse(contextEl.value)
    contextEl.value = formatJSON(parsed)
    resizeContext()
  } catch (e) { /* invalid JSON, leave as-is */ }
})
resizeContext()

// Tab switching
document.querySelectorAll('.output-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    const target = tab.dataset.tab
    document.querySelectorAll('.output-tab').forEach(t => t.classList.toggle('active', t === tab))
    document.getElementById('evalPanel').classList.toggle('active', target === 'eval')
    document.getElementById('treePanel').classList.toggle('active', target === 'tree')
  })
})

// Debounce
let timer
const debounce = fn => { clearTimeout(timer); timer = setTimeout(fn, 100) }

// Compile only (no execution)
function compile() {
  errorEl.textContent = ''
  astEl.textContent = ''
  currentAST = null

  const code = inputEl.value.trim()
  if (!code || !worker || !workerReady) return

  try { worker.postMessage({ type: 'compile', id: evalId, code }) }
  catch (e) { /* Worker terminated */ }
}

// Run (execute with context)
function run() {
  resultEl.textContent = ''
  resultEl.classList.remove('err')

  const code = inputEl.value.trim()
  if (!code || !worker || !workerReady) return

  let ctx = {}
  try { ctx = JSON.parse(contextEl.value || '{}') }
  catch (e) { resultEl.textContent = `Context: ${e.message}`; resultEl.classList.add('err'); return }

  try { worker.postMessage({ type: 'run', id: evalId, code, ctx }) }
  catch (e) { /* Worker terminated */ }
}

inputEl.addEventListener('input', () => { updateEditor(); debounce(compile) })

// Run button
document.getElementById('runBtn').addEventListener('click', run)

// Cmd+Enter to run
document.addEventListener('keydown', e => {
  if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
    e.preventDefault()
    run()
  }
})

// Tab in editor
inputEl.addEventListener('keydown', e => {
  if (e.key === 'Tab') {
    e.preventDefault()
    const s = inputEl.selectionStart
    inputEl.value = inputEl.value.slice(0, s) + '  ' + inputEl.value.slice(inputEl.selectionEnd)
    inputEl.selectionStart = inputEl.selectionEnd = s + 2
    updateEditor()
    debounce(compile)
  }
})

// Update editor with generated example
function updateExample() {
  const ex = generateExample()
  inputEl.value = ex.code
  contextEl.value = formatJSON(ex.ctx)
  updateEditor()
  resizeContext()
}

// Render features
let programmaticChange = false
const featuresEl = document.getElementById('features')
FEATURES.forEach(cat => {
  featuresEl.insertAdjacentHTML('beforeend', `<div class="cat-head">${cat.cat}</div>`)
  cat.items.forEach(id => {
    const el = document.createElement('label')
    el.className = 'feat'
    el.innerHTML = `<input type="checkbox" data-id="${id}" ${selected.has(id) ? 'checked' : ''}>${id}<span class="feat-desc">${DESC[id]}</span>`
    el.querySelector('input').addEventListener('change', async e => {
      if (programmaticChange) return
      const enabled = e.target.checked
      enabled ? selected.add(id) : selected.delete(id)
      updatePresetSelect()
      await rebuildWorker()
      updateExample()
      compile()
    })
    featuresEl.appendChild(el)
  })
})

// Preset select
const presetSelect = document.getElementById('presetSelect')
presetSelect.addEventListener('change', async () => {
  if (presetSelect.value === 'custom') return
  selected = new Set(PRESETS[presetSelect.value])
  programmaticChange = true
  document.querySelectorAll('.feat input').forEach(cb => cb.checked = selected.has(cb.dataset.id))
  programmaticChange = false
  await rebuildWorker()
  updateExample()
  compile()
})

function updatePresetSelect() {
  const match = Object.entries(PRESETS).find(([k, v]) => v.length === selected.size && v.every(x => selected.has(x)))
  if (match) {
    presetSelect.value = match[0]
    presetSelect.querySelector('[value=custom]').hidden = true
  } else {
    presetSelect.querySelector('[value=custom]').hidden = false
    presetSelect.querySelector('[value=custom]').disabled = false
    presetSelect.value = 'custom'
  }
}

// Sidebar toggle
const sidebar = document.getElementById('sidebar')
const toggleBtn = document.getElementById('toggleSidebar')
toggleBtn.addEventListener('click', () => {
  sidebar.classList.toggle('collapsed')
  const chevron = toggleBtn.querySelector('svg')
  chevron.style.transform = sidebar.classList.contains('collapsed') ? 'rotate(180deg)' : ''
})

// Bundle generation - import version imports subscript first
function generateImportBundle() {
  const imports = featureOrder.filter(f => selected.has(f)).map(f => `import 'subscript/feature/${f}.js'`).join('\n')
  return `// subscript dialect (${selected.size} features)
import { parse } from 'subscript/parse'
import compile from 'subscript/compile'
${imports}
export { parse, compile }
export default s => compile(parse(s))
`
}

function generateSelfContainedBundle() {
  return buildWorkerSrc()
    .replace(/\/\/ Worker handler[\s\S]*$/, '')
    .trim() + '\n'
}

// Simple minification
function minify(code) {
  return code
    .replace(/\/\/.*$/gm, '')
    .replace(/\/\*[\s\S]*?\*\//g, '')
    .replace(/\n\s*\n/g, '\n')
    .replace(/^\s+/gm, '')
    .replace(/\s+$/gm, '')
    .replace(/\n/g, ' ')
    .replace(/\s+/g, ' ')
    .replace(/\s*([{}();,:])\s*/g, '$1')
    .replace(/\s*([=+\-*/<>!&|?])\s*/g, '$1')
    .trim()
}

// Size formatting
function formatSize(bytes) {
  if (bytes < 1024) return bytes + ' B'
  return (bytes / 1024).toFixed(1) + ' KB'
}

// Gzip size
async function gzipSize(str) {
  if (typeof CompressionStream === 'undefined') {
    return Math.floor(str.length * 0.3)
  }
  const blob = new Blob([str])
  const cs = new CompressionStream('gzip')
  const stream = blob.stream().pipeThrough(cs)
  const compressedBlob = await new Response(stream).blob()
  return compressedBlob.size
}

// Modal
const bundleModal = document.getElementById('bundleModal')
const modalCode = document.getElementById('modalCode')
const bundleToggle = document.getElementById('bundleToggle')
const minToggle = document.getElementById('minToggle')
const sizeInfo = document.getElementById('sizeInfo')
let currentBundleCode = ''

async function updateModalCode() {
  const isBundle = bundleToggle.checked
  const isMin = minToggle.checked

  let code = isBundle ? generateSelfContainedBundle() : generateImportBundle()
  if (isMin) code = minify(code)

  currentBundleCode = code
  modalCode.textContent = code

  // Update size - show both raw and gzip
  const rawSize = new Blob([code]).size
  const gzip = await gzipSize(code)
  sizeInfo.textContent = `${formatSize(rawSize)} / ${formatSize(gzip)} gzip`
}

document.getElementById('getBundleBtn').addEventListener('click', () => {
  updateModalCode()
  bundleModal.classList.add('open')
})

bundleModal.addEventListener('click', e => {
  if (e.target === bundleModal) bundleModal.classList.remove('open')
})

bundleToggle.addEventListener('change', updateModalCode)
minToggle.addEventListener('change', updateModalCode)

document.getElementById('modalDownload').addEventListener('click', () => {
  const isBundle = bundleToggle.checked
  const isMin = minToggle.checked
  const filename = isBundle ? (isMin ? 'dialect.min.js' : 'dialect.bundle.js') : 'dialect.js'
  const a = document.createElement('a')
  a.href = URL.createObjectURL(new Blob([currentBundleCode], { type: 'text/javascript' }))
  a.download = filename
  a.click()
})

// Copy handlers - select full text and copy
function copyBundle(btn) {
  // Select text in modalCode
  const range = document.createRange()
  range.selectNodeContents(modalCode)
  const sel = window.getSelection()
  sel.removeAllRanges()
  sel.addRange(range)

  navigator.clipboard.writeText(currentBundleCode)
  const origHTML = btn.innerHTML
  btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M5 13l4 4L19 7"/></svg> Copied!'
  setTimeout(() => { btn.innerHTML = origHTML }, 1500)
}

document.getElementById('codeCopyBtn').addEventListener('click', function() { copyBundle(this) })

// Escape to close modal
document.addEventListener('keydown', e => {
  if (e.key === 'Escape' && bundleModal.classList.contains('open')) {
    bundleModal.classList.remove('open')
  }
})

// Init
updatePresetSelect()
await rebuildWorker()
updateExample()
compile()
</script>
</body>
</html>
