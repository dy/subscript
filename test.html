<script type="module">
  import test, {is} from './lib/test.js'
  import {parse, evaluate} from '../subscript.js'

  test('parse: basic', t => {
    is(parse('0 + 1 + 2'), ['+', 0, 1, 2])
    is(parse('0 + (1 + 2)'), ['+', 0, ['+', 1, 2]])
    is(parse('0 + 1 - 2'), ['-', ['+', 0, 1], 2])
    is(parse('0 - 1 + 2'), ['+', ['-',0, 1], 2])
    is(parse('0 + 1 + 2 - 1 - 2 + 1'), ['+', ['-', ['+', 0, 1, 2], 1, 2], 1])
    is(parse('0 - 1 - 2 + 1 + 2 - 1'), ['-', ['+', ['-', 0, 1, 2], 1, 2], 1])
    is(parse('0 * 1 * 2 / 1 / 2 * 1'), ['*', ['/', ['*', 0, 1, 2], 1, 2], 1])
    is(parse('0 / 1 / 2 * 1 * 2 / 1'), ['/', ['*', ['/', 0, 1, 2], 1, 2], 1])
    is(parse('0 + 1 - 2 * 3'), ['-', ['+', 0, 1], ['*', 2, 3]])
    is(parse('1 * 2 - 3'), ['-', ['*',1,2], 3])
    is(parse('1 + a.b + 3.5'), ['+', 1, ['.','a','"b"'], 3.5])
    is(parse('1 + (a.b + 3.5)'), ['+', 1, ['+', ['.','a','"b"'], 3.5]])
    is(parse('1 + x(a.b + 3.5)'), ['+', 1, ['x', ['+', ['.','a','"b"'], 3.5]]])
    is(parse('1 + x(a[b] + 3.5)'), ['+', 1, ['x', ['+', ['.','a','b'], 3.5]]])
    is(parse('x.y.z(123)'), [['.','x','"y"','"z"'],123])
    is(parse('x.y.z(123 + c[456]) + n'), ['+',[['.','x','"y"','"z"'],['+',123, ['.','c',456]]],'n'])
    is(parse('1 || 1'), ['||', 1, 1])
    // WARN: -1%2 can be a problem: it first divides then adds minus...
    // although seems to be fine for -+ unaries
    is(parse('-1%2'), ['%',['-',1]])
    // is(parse('+1 * (a.b - 3.5) - "asdf" || x.y.z(123 + c[456]) + n'),
    //   ['||',
    //     ['-',['*',['+',1],['-',['.','a','"b"'],3.5]], '"asdf"'],
    //     ['+',[['.','x','"y"','"z"'], ['+',123,['.','c',456]]],'n']
    //   ]
    // )
  })
  test('parse: intersecting operators', t => {
    is(parse('a | b'), ['|', 'a', 'b'], 'a|b')
    is(parse('a || b'), ['||', 'a', 'b'], 'a||b')
    is(parse('a & b'), ['&', 'a', 'b'], 'a&b')
    is(parse('a && b'), ['&&', 'a', 'b'], 'a&&b')
  })
  test('parse: signs', t => {
    is(parse('+-1'),['+',['-',1]])
    is(parse('1+-1'),['+',1,['-',1]])
    is(parse('+1-+-1'),['-',['+',1],['+',['-',1]]])
    is(parse('+1-+-a[1]'),['-',['+',1],['+',['-',['.','a',1]]]])
    is(parse('+1 + +2'),['+',['+',1],['+',2]])
    is(parse('+1 + -2'),['+',['+',1],['-',2]])
    is(parse('+1 -+2'),['-',['+',1],['+',2]])
    is(parse('1 -2'),['-',1,2])
    is(parse('+1 -2'),['-',['+',1],2])
    is(parse('-1 +2'),['+',['-',1],2])
  })
  test('parse: unaries', t => {
    is(parse('-2'),['-',2])
    is(parse('+-2'),['+',['-',2]])
    is(parse('-+-2'),['-',['+',['-',2]]])
    is(parse('-+~2'),['-',['+',['~',2]]])
    is(parse('1-+-2'),['-',1,['+',['-',2]]])
    is(parse('1-+~2'),['-',1,['+',['~',2]]])
    is(parse('1 * -1'),['*',1,['-',1]])
  })
  test.skip('parse: json', t => {
    is(parse('{}'), {})
    is(parse('{x: 1}'), {x: 1})
    is(parse('{x: 1, "y":2}'), {x:1, y:2})
    is(parse('{x: 1+2, y:a(3)}'), {x:['+',1,2], y:['a',3]})
    // is(parse('[1,2,3]'), [Array,1,2,3]) // no-op group means array
    // is(parse('(1,2,3)'), [',',1,2,3]) // FIXME: must differentiate with previous
  })

  test.skip('parse: list', t => {
    is(parse('[1,,2,3]'),['[',[',',1,undefined,2,3]])
  })

  test('parse: prop access', t => {
    is(parse('a["b"]["c"][0]'),['.','a','"b"','"c"',0])
    is(parse('a.b.c.0'), ['.','a','"b"','"c"',0])
    is(evaluate(['.','a','b','c',0], {a:{b:{c:[2]}}}), 2)
    is(evaluate(['.','a','"b"','"c"',0], {a:{b:{c:[2]}}}), 2)
    is(evaluate(acc, {a:{b:{c:[2]}}}), 2)
  })

  test('parse: parens', t => {
    is(parse('+b'),['+','b'])
    is(parse('+(b)'),['+','b'])
    is(parse('+((b))'),['+','b'])
    is(parse('++(b)'),['+',['+','b']])
    // is(parse('++a(b)'),['+',['+',['a', 'b']]])
    // is(parse('++a(b)'),['+',['+',['a', 'b']]])
    // is(parse('+(b)'),['+',[,'b']])
    // is(parse('1+(b)'),['+',1,[,'b']])
    // is(parse('1+((b))'),['+',1,[,'b']])
    // is(parse('1++(b)'),['+',1,['+',['b']])
    // is(parse('(1)+-b'),['+',1,['+',['b']])
    // is(parse('x[1]+-b'),['+',1,['+',['b']])
    // is(parse('x[+-1]'),['+',1,['+',['b']])
    // is(parse('(+-1)'),['+',1,['+',['b']])
    // is(parse('x(+-1)'),['+',1,['+',['b']])

  })

  test('parse: functions', t => {
    is(parse('a()'),['a'])
    is(parse('(c,d)'),[',', 'c','d'])
    is(parse('a(b)(d)'),[['a', 'b'], 'd'])
    is(parse('a(b,c)(d)'),[['a', 'b','c'], 'd'])
    is(parse('(c)(e)'),['c','e'])
    is(parse('b(c,d)'),['b', 'c','d'])
    is(parse('b(c)(e)'),[['b', 'c'],'e'])
    is(parse('(c,d)(e)'),[[',', 'c','d'],'e'])
    is(parse('a.b(c,d)'),[['.','a','"b"'], 'c','d'])
    is(parse('a.b(c.d)'),[['.','a','"b"'],['.', 'c','"d"']])
  })

  test('parse: chains', t => {
    is(parse('a["b"]["c"]["d"]'),['.','a','"b"','"c"','"d"'])
    is(parse('a.b.c.d'),['.','a','"b"','"c"','"d"'])
    is(parse('a.b[c.d].e.f'),['.','a','"b"',['.', 'c','"d"'],'"e"','"f"'])
    is(parse('a.b(1).c.d'),['.',[['.','a','"b"'],1], '"c"', '"d"'])
    is(parse('a.b(1)(2).c.d'),['.',[[['.','a','"b"'],1],2], '"c"', '"d"'])
    is(parse('a.b(1)(2)'),[[['.','a','"b"'],1],2])
    is(parse('a.b()()'),[[['.','a','"b"']]])
    is(parse('a()()()'),[[['a']]])
    is(parse('(a)()()'),[['a']])
    is(parse('a.b().e.f'),['.',[['.','a','"b"']],'"e"','"f"'])
    is(parse('a.b(c.d).e.f'),['.',[['.','a','"b"'],['.', 'c','"d"']],'"e"','"f"'])
    is(parse('(c.d).e.f'),['.',['.', 'c','"d"'],'"e"','"f"'])
    is(parse('a.b(c.d).e(f).g()'),[['.',[['.',[['.','a','"b"'],['.','c','"d"']],'"e"'],'f'],'"g"']])
    is(parse('a.b[c.d].e'),['.','a','"b"',['.','c','"d"'],'"e"'])
    is(parse('a.b[c.d].e.f(g.h)'),[['.','a','"b"',['.','c','"d"'],'"e"','"f"'], ['.','g','"h"']])
    is(parse('a(b)(c)'),[['a','b'],'c'])
    is(parse('a(1,2)(b)'),[['a',1, 2],'b'])
    is(parse('(1,2)(b)'),[[',', 1, 2],'b'])
    is(parse('+(1,2)(b)'),['+',[[',', 1, 2],'b']])
    is(parse('a[b][c]'),['.','a','b','c'])
    is(parse('a[1](b)["c"]'),['.', [['.', 'a', 1], 'b'], '"c"'])
    is(parse('a(1)[b]("c")'),[['.', ['a', 1], 'b'], '"c"'])
    is(parse('a[1][b]["c"]'),['.', 'a', 1, 'b', '"c"'])
    is(parse('a(1)(b)("c")'),[[['a', 1], 'b'], '"c"'])
  })

  test('parse: word operator', t => {
    is(parse('inc in bin'), [' in ', 'inc', 'bin'])
    // is(evaluate('inc in bin', {bin:{inc:1}}), true)
  })

  test('eval: basic', t => {
    is(evaluate(['+', 1, 2]), 3)
    is(evaluate(['+', 1, ['-', 3, 2]]), 2)
    is(evaluate(['-', 5, 2, 1, 1]), 1)
    is(evaluate(['+',['-',1]]), -1)
    is(evaluate(['-',['+',1],2]), -1)
  })

</script>
