<script type="module">
  import test, {is, any} from '../lib/test.js'
  import subscript, {parse, evaluate, quotes, binary, groups, literals, transforms} from '../subscript.js'

  test('jsep strip', t => {
    binary[2]['**']=true
    quotes["'"]="'"
    is(parse('1 + 2 * 3'), ['+',1, ['*', 2, 3]])
    any(parse('1 + 2 + 3'), ['+', ['+', 1, 2], 3],   ['+', 1, 2, 3])
    any(parse('1 + 2 + 3 + 4'), ['+', ['+', ['+', 1, 2], 3], 4],   ['+', 1, 2, 3, 4])
    is(parse('1 * 2 + 3'), ['+', ['*', 1, 2], 3])
    any(parse('1 + 2 * 3 + 4'), ['+', ['+', 1, ['*', 2, 3]], 4],    ['+', 1, ['*', 2, 3], 4])
    any(parse('1 + 2 * 3 ** 4 + 5'), ['+', ['+', 1, ['*', 2, ['**', 3, 4]]], 5],  ['+', 1, ['*', 2, ['**', 3, 4]], 5])
    any(parse('a.b.c(d).e'), ['.',[['.', ['.','a','b'],'c'],'d'],'e'],    ['.',[['.','a','b','c'],'d'],'e'])
    is(parse(`+-2`), ['+',['-',2]])
    is(parse(`a + b * c ** d | e`), ['|', ['+', 'a', ['*', 'b', ['**','c', 'd']]], 'e'])
    is(parse(`1+(2+3)`), ['+',1, ['+',2,3]])
    is(parse(`1+(2)`), ['+',1, 2])
    any(parse(`1+(2)+3+((4))`), ['+',['+',['+',1, 2],3],4],  ['+',1, 2,3,4])
    is(parse(`1+-2`), ['+',1,['-',2]])
    is(parse(`-a.b+1`), ['+',['-',['.','a','b']], 1])
    is(parse(`-a-b`), ['-',['-','a'], 'b'])
    is(parse(`+-a.b+-!1`), ['+',['+',['-',['.','a','b']]], ['-',['!',1]]])
    is(parse(`"abcd" + 'efgh'`), ['+','abcd','efgh'])
    is(parse(`   .1   +   -1.0 -  2.3e+1 `), ['-', ['+', .1, ['-',1]], 23])
    is(parse(`a(1)`), [['a'], 1])
    is(parse(`a(1).b`), ['.',[['a'], 1],'b'])

    is(parse(`a ( c ) . e`), ['.',['a', 'c'], 'e'])

    is(parse(`a.b (  ccc. d, , -+1.0 ) . e`), ['.',[['.', 'a', 'b'], ['.', 'ccc', 'd'], null, ['-',['+',1]]], 'e'])
    is(parse(`(a + 2) * 3 / 2 + b * 2 - 1`), ['-',['+',['/',['*',['+', 'a', 2],3],2],['*', 'b', 2]],1])
    is(parse('a()()()'),[[['a']]])
    is(parse('a(b)(c)'),[['a', 'b'],'c'])
    any(parse('a[b][c]'),['.','a', 'b', 'c'], ['.',['.', 'a', 'b'], 'c'])
  })

  test('readme', t => {
    let fn = subscript(`a.b + c(d-1)`)
    is(fn({a:{b:1}, c:x=>x*2, d:3}), 5)

    quotes["'"] = "'"
    is(parse("'a' + 'b'"), ['+', "a", "b"])

    is(evaluate(['+', ['*', 'min', 60], new String('sec')], {min: 5}), "300sec")
  })

  test.todo('parse: basic', t => {
    is(parse('0 + 1 + 2.0'), ['+', ['+', 0, 1], 2])
    is(parse('0 + (1 + 2)'), ['+', 0, ['+', 1, 2]])
    is(parse('-2 - 2'), ['-', ['-', 2], 2])
    is(parse('0 + 1 - 2'), ['-', ['+', 0, 1], 2])
    is(parse('0 - 1 + 2'), ['+', ['-',0, 1], 2])
    is(parse('0 + 1 + 2 - 1 - 2 + 1'), ['+', ['-', ['-', ['+', ['+', 0, 1], 2], 1], 2], 1])
    is(parse('0 * 1 * 2 / 1 / 2 * 1'), ['*', ['/', ['/', ['*', ['*', 0, 1], 2], 1], 2], 1])
    is(parse('0 + 1 - 2 * 3'), ['-', ['+', 0, 1], ['*', 2, 3]])
    is(parse('1 * 2 - 3'), ['-', ['*',1,2], 3])
    is(parse('a.b'), ['.','a','b'])
    is(parse('1 + a.b + 3.5'), ['+',['+', 1, ['.','a','b']], 3.5])
    is(parse('1 + (a.b + 3.5)'), ['+', 1, ['+', ['.','a','b'], 3.5]])
    is(parse('x(a + 3)'), ['x', ['+', 'a', 3]])
    is(parse('1 + x(a.b + 3.5)'), ['+', 1, ['x', ['+', ['.','a','b'], 3.5]]])
    is(parse('a[b]'), ['.','a','b'])
    is(parse('(a(b) + 3.5)'), ['+', ['a','b'], 3.5])
    is(parse('1 + x(a[b] + 3.5)'), ['+', 1, ['x', ['+', ['.','a','b'], 3.5]]])
    is(parse('x.y.z,123'), [['.',['.', 'x','y'],'z'],123])
    any(parse('x.y.z(123)'), [['.','x','y','z'],123], [['.',['.','x','y'],'z'],123])
    any(parse('x.y.z(123 + c[456]) + n'), ['+', [['.','x','y','z'],['+',123, ['.','c',456]]],'n'], ['+', [['.',['.','x','y'],'z'],['+',123, ['.','c',456]]],'n'])
    is(parse('1 || 1'), ['||', 1, 1])
    is(parse('-1%2'), ['%',['-',1], 2])
    is(parse('-(1%2)'), ['-',['%',1, 2]])
    any(parse('+1 * (a.b - 3.5) - "asdf" || x.y.z(123 + c[456]) + n'),
      ['||',
        ['-',['*',['+',1],['-',['.','a','b'],3.5]], 'asdf'],
        ['+',[['.','x','y','z'], ['+',123,['.','c',456]]],'n']
      ],
      ['||',
        ['-',['*',['+',1],['-',['.','a','b'],3.5]], 'asdf'],
        ['+',[['.',['.','x','y'],'z'], ['+',123,['.','c',456]]],'n']
      ]
    )
  })

  test.skip('parse: interpolate string', t => {
    is(parse`a+1`, ['+','a',1])
    is(subscript`a+1`({a:1}), 2)
  })

  test('parse: strings', t => {
    is(parse('"a"'), 'a')
    is(parse('a + b'), ['+', 'a', 'b'])
    is(parse('"a" + "b"'), ['+', 'a', 'b'])
    is(parse('"a" + ("1" + "2")'), ['+', 'a', ['+', '1', '2']])

    // quotes['<?']='?>'
    // is(parse('"abc" + <?js\nxyz?>'), ['+','"abc"','<?js\nxyz?>'])

    // quotes['<--']='-->'
    // is(parse('"abc" + <--js\nxyz-->'), ['+','"abc"','<--js\nxyz-->'])
  })
  test.todo('parse: comments', t => {
    comments['//']='\n'
    is(parse(`a /
      // abc
      b`), ['/', 'a', 'b'])
    is(parse(`'a' + 'b' // concat`),['+',"'a'","'b'"])
  })
  test('parse: literals', t=> {
    is(parse('null'), null)
    literals['undefined'] = undefined
    is(parse('(undefined)'), undefined)
    is(parse('true||((false))'), ['||', true, false])
    is(parse('a(true)'), ['a', true])
  })
  test('parse: intersecting binary', t => {
    is(parse('a | b'), ['|', 'a', 'b'], 'a|b')
    is(parse('a || b'), ['||', 'a', 'b'], 'a||b')
    is(parse('a & b'), ['&', 'a', 'b'], 'a&b')
    is(parse('a && b'), ['&&', 'a', 'b'], 'a&&b')

    is(parse('a >> b'), ['>>', 'a', 'b'], 'a>>b')
    is(parse('a >>> b'), ['>>>', 'a', 'b'], 'a>>>b')
  })
  test('parse: signs', t => {
    is(parse('+-1'),['+',['-',1]])
    is(parse('a(+1)'),['a',['+',1]])
    is(parse('a[+1]'),['.', 'a',['+',1]])
    is(parse('a+(1)'),['+','a',1])
    is(parse('a+!1'),['+','a',['!',1]])
    is(parse('a+-1'),['+','a',['-',1]])
    is(parse('1+-1.23e-2-1.12'),['-',['+',1,['-',1.23e-2]], 1.12])
    is(parse('-+(1)'),['-',['+',1]])
    is(parse('+1.12-+-a+-(+1)'),['+', ['-',['+',1.12],['+',['-','a']]],['-',['+',1]]])
    is(parse('+1.12-+-a[+1]'),['-',['+',1.12],['+',['-',['.','a',['+',1]]]]])
    is(parse('+1-+-1'),['-',['+',1],['+',['-',1]]])
    is(parse('-a[1]'),['-',['.','a',1]])
    is(parse('-a.b[1](2)'),['-',[['.',['.','a','b'], 1], 2]])
    is(parse('+1-+-a[1]'),['-',['+',1],['+',['-',['.','a',1]]]])
    is(parse('+1 + +2'),['+',['+',1],['+',2]])
    is(parse('+1 + -2'),['+',['+',1],['-',2]])
    is(parse('+1 -+2'),['-',['+',1],['+',2]])
    is(parse('1 -2'),['-',1,2])
    is(parse('+1 -2'),['-',['+',1],2])
    is(parse('-1 +2'),['+',['-',1],2])
  })
  test('parse: unaries', t => {
    is(parse('-2'),['-',2])
    is(parse('+-2'),['+',['-',2]])
    is(parse('-+-2'),['-',['+',['-',2]]])
    is(parse('-+!2'),['-',['+',['!',2]]])
    is(parse('1-+-2'),['-',1,['+',['-',2]]])
    is(parse('1-+!2'),['-',1,['+',['!',2]]])
    is(parse('1 * -1'),['*',1,['-',1]])
  })
  test.todo('parse: postfix unaries', t => {
    is(parse('2-'),['-',2])
    is(parse('2-+'),['+',['-',2]])
    is(parse('2-+-'),['-',['+',['-',2]]])
    is(parse('2!+-'),['-',['+',['!',2]]])
    is(parse('1---2'),['-',['--',1], 2])
    is(parse('1!+2'),['+',['!',1],2])
    is(parse('1 * -1'),['*',1,['-',1]])
  })

  test('parse: prop access', t => {
    any(parse('a["b"]["c"][0]'),['.',['.',['.','a','b'],'c'],0],  ['.', 'a', 'b', 'c', 0])
    any(parse('a.b.c.0'), ['.',['.',['.','a','b'],'c'],0],  ['.', 'a', 'b', 'c', 0])
    is(evaluate(['.','a','b','c',0], {a:{b:{c:[2]}}}), 2)
    is(evaluate(['.',['.',['.','a','b'],new String('c')],0], {a:{b:{c:[2]}}}), 2)
  })

  test('parse: parens', t => {
    is(parse('1++(b)'),['+',1,['+','b']]) // NOTE: not supported by JS btw
    is(parse('1+(b)()'),['+',1,['b']])
    is(parse('(1)+-b()'),['+',1,['-',['b']]])
    is(parse('1+a(b)'),['+',1,['a','b']])
    is(parse('1+(b)'),['+',1,'b'])
    is(parse('1+-(b)'),['+',1,['-','b']])
    is(parse('(b)'),'b')
    is(parse('+b'),['+','b'])
    is(parse('+(b)'),['+','b'])
    is(parse('+((b))'),['+','b'])
    is(parse('++(b)'),['++','b'])
    is(parse('++a(b)'),['++',['a', 'b']])
    is(parse('+(b)'),['+','b'])
    is(parse('1+(b)'),['+',1,'b'])
    is(parse('1+((b))'),['+',1,'b'])
    is(parse('(1)+-b'),['+',1,['-','b']])
    is(parse('x[1]+-b'),['+',['.','x',1],['-','b']])
    is(parse('x[+-1]'),['.','x',['+',['-',1]]])
    is(parse('(+-1)'),['+',['-',1]])
    is(parse('x(+-1)'),['x',['+',['-',1]]])
    is(parse('(1,2,3)'),[',',1,2,3])
  })

  test('parse: functions', t => {
    is(parse('a()'),['a'])
    is(parse('(c,d)'),[',', 'c','d'])
    is(parse('a(b)(d)'),[['a', 'b'], 'd'])
    is(parse('a(b,c)(d)'),[['a', 'b','c'], 'd'])
    is(parse('(c)(e)'),['c','e'])
    is(parse('b(c,d)'),['b', 'c','d'])
    is(parse('b(c)(e)'),[['b', 'c'],'e'])
    is(parse('(c,d)(e)'),[[',', 'c','d'],'e'])
    is(parse('a.b(c,d)'),[['.','a','b'], 'c','d'])
    is(parse('a.b(c.d)'),[['.','a','b'],['.', 'c','d']])
  })

  test('parse: chains', t => {
    any(parse('a["b"]["c"]["d"]'),['.','a','b','c','d'], ['.',['.',['.','a','b'],'c'],'d'])
    any(parse('a.b.c.d'),['.','a','b','c','d'], ['.',['.',['.','a','b'],'c'],'d'])
    any(parse('a.b[c.d].e.f'),['.',['.',['.',['.','a','b'], ['.','c','d']],'e'],'f'],   ['.',['.','a','b'],['.','c','d'],'e','f'])
    is(parse('a.b(1)(2).c'),['.',[[['.','a','b'],1],2], 'c'])
    is(parse('a.b(1)(2)'),[[['.','a','b'],1],2])
    is(parse('a()()()'),[[['a']]])
    is(parse('a.b()()'),[[['.','a','b']]])
    is(parse('(a)()()'),[['a']])
    any(parse('a.b(c.d).e.f'),['.',['.',[['.','a','b'],['.','c','d']],'e'],'f'],  ['.',[['.','a','b'],['.','c','d']],'e','f'])
    any(parse('(c.d).e'),['.',['.', 'c','d'],'e'], ['.', 'c','d','e'])
    is(parse('a.b(c.d).e(f).g()'),[['.',[['.',[['.','a','b'],['.','c','d']],'e'],'f'],'g']])
    any(parse('a.b[c.d].e'),['.',['.',['.','a','b'],['.','c','d']],'e'],   ['.',['.','a','b'],['.','c','d'],'e'])
    any(parse('a.b[c.d].e(g.h)'),[['.',['.',['.','a','b'],['.','c','d']],'e'],['.','g','h']],  [['.',['.','a','b'],['.','c','d'],'e'], ['.','g','h']])
    is(parse('a(b)(c)'),[['a','b'],'c'])
    is(parse('a(1,2)(b)'),[['a',1, 2],'b'])
    is(parse('(1,2)(b)'),[[',', 1, 2],'b'])
    is(parse('+(1,2)(b)'),['+',[[',', 1, 2],'b']])
    is(parse('a[b][c]'),['.',['.','a','b'],'c'])
    is(parse('a[1](b)["c"]'),['.', [['.', 'a', 1], 'b'], 'c'])
    is(parse('a(1)[b]("c")'),[['.', ['a', 1], 'b'], 'c'])
    is(parse('a[1][b]["c"]'),['.',['.',['.', 'a', 1], 'b'], 'c'])
    is(parse('a(1)(b)("c")'),[[['a', 1], 'b'], 'c'])
  })

  test('eval: basic', t => {
    is(evaluate(['+', 1, 2]), 3)
    is(evaluate(['+', 1, ['-', 3, 2]]), 2)
    is(evaluate(['-', 5, 2, 1, 1]), 1)
    is(evaluate(['+',['-',1]]), -1)
    is(evaluate(['-',['+',1],2]), -1)
  })

  test('ext: in operator', t => {
    binary[5]['in'] = (a,b)=>a in b
    transforms['in'] = n => (n[1]=`"${n[1]}"`, n)

    is(parse('inc in bin'), ['in', 'inc', 'bin'])
    is(evaluate(parse('inc in bin'), {bin:{inc:1}}), true)
  })

  test('ext: ternary', t => {
    let comma = binary.pop()
    binary.push({':':(a,b)=>[a,b], '?':(a,b)=>a??b, '?:':(a,b,c)=>a?b:c})
    binary.push(comma)

    transforms[':'] = node => node[1][0]=='?' ? ['?:',node[1][1],node[1][2],node[2]] : node // [:, [?, a, b], c] → [?:, a, b, c]
    is(parse('a ? b : c'),['?:','a','b','c']) // ['?:', 'a', 'b', 'c']

    // bonus side-effect:
    is(parse('a ? b'), ['?', 'a', 'b'])
    is(parse('a : b'), [':', 'a', 'b'])

    is(evaluate(parse('a?b:c'), {a:true,b:1,c:2}), 1)
    is(evaluate(parse('a?b:c'), {a:false,b:1,c:2}), 2)
  })

  test('ext: list', t => {
    binary.unshift({'[':a=>Array(...a)})
    transforms['['] = s => s.length > 2 ? s
      : s[1] === undefined
      ? [Array]
      // ['[',[',',a,[',',b],c]] → ['[',[',',a,,b,c]]
      : [Array].concat(isnode(s[1]) ? s[1].slice(1).reduce((a,b)=>a.push(...(isnode(b)&&b[0]==','?(b[0]=undefined,b):[b]))&&a,[])
      : s[1])

    is(parse('[]'),[Array])
    is(parse('[1]'),[Array,1])
    is(parse('[1,,2,b]'),[Array,1,undefined,2,'b'])
    is(parse('[1]+[2]'),['+',[Array,1],[Array,2]])
    is(evaluate(parse('[1,,2,b]'),{b:3}),[1,undefined,2,3])
  })

  test('ext: object', t => {
    blocks['{']='}'
    binary.unshift({'{':a=>Object.fromEntries(a)})
    binary[binary.length-2][':']=(a,b)=>[a,b]
    transforms['{'] = (s,entries) => {
      if (s[1]===undefined) return {}
      if (s[1][0]==':') entries = [s[1].slice(1)]
      else entries = s[1].slice(1).map(n=>n.slice(1))
      entries = entries.map(n=>quotes[n[0][0]]?[n[0].slice(1,-1),n[1]]:n)
      return Object.fromEntries(entries)
    }

    is(parse('{}'), {})
    is(parse('{x: 1}'), {x: 1})
    is(parse('{x: 1, "y":2}'), {x:1, y:2})
    is(parse('{x: 1+2, y:a(3)}'), {x:['+',1,2], y:['a',3]})
  })

  test('ext: justin', async t => {
    const {parse} = await import('./justin.js')

    is(parse('{x:1, "y":2+2}["x"]'), ['[', {x:1, y: ['+', 2, 2]}, 'x'])
  })


  test('eval: edge cases', t => {
    is(evaluate(parse('Math.pow(a, 3) / 2 + b * 2 - 1'), {Math, a:1, b:1}), 1.5)
  })

</script>
